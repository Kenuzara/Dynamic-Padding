/*!
 * Dynamic Padding  |  @ver: 2.0  |  @author: Chris McClean
 * Copyright September 2013, Chris McClean  |  Dual licensed under the MIT or GPL Version 2 licenses.  
 * http://www.gnu.org/licenses/gpl.html  |  http://opensource.org/licenses/mit-license.php 
 * Credits: Original script written by Les James @ http://www.lesjames.com
 **/
; (function (e) { var t = { init: function (t) { return this.each(function () { var n = e(this); var r = e(n).data("dynPadding"); if (typeof r == "undefined") { var i = { targets: "#nav a", remainder: null, vertical: false, paddingBoundary: 34 }; r = e.extend(i, t); e(n).data("dynPadding", r) } else { r = e.extend({}, r, t) } var s = 0, o = 0, u = 0, a = e(t.targets).length; if (t.vertical) { s = n.height() } else { s = n.width() } e(n).addClass("dynPadding_parent"); if (t.vertical) { e(t.targets).each(function () { e(this).css({ "padding-top": "0", "padding-bottom": "0" }); u += e(this).outerHeight(); o = e(this).height(); e(this).css({ height: o + "px" }) }) } else { e(t.targets).each(function () { e(this).css({ "padding-left": "0", "padding-right": "0" }); u += e(this).outerWidth(true); o = e(this).width() + 1; e(this).css({ width: o + "px" }) }) } var f = (s - u) / a, l = Math.floor(f); if (l >= t.paddingBoundary) { l = parseInt(t.paddingBoundary - 2) } if (t.remainder != null) { remainder = Math.round((f - l) * a); if (remainder >= Math.floor(t.paddingBoundary / 2)) { remainder = Math.floor(t.paddingBoundary / 2) - 1 } if (t.vertical) { e(t.targets).css({ "padding-top": Math.floor(l / 2), "padding-bottom": Math.floor(l / 2) }); e(t.remainder).css({ "padding-top": Math.floor(remainder / 2) + Math.floor(l / 2), "padding-bottom": Math.floor(remainder / 2) + Math.floor(l / 2) }) } else { e(t.targets).css({ "padding-left": Math.floor(l / 2), "padding-right": Math.floor(l / 2) }); e(t.remainder).css({ "padding-left": Math.floor(remainder / 2) + Math.floor(l / 2), "padding-right": Math.floor(remainder / 2) + Math.floor(l / 2) }) } } else { if (t.vertical) { e(t.targets).css({ "padding-top": Math.floor(l / 2), "padding-bottom": Math.floor(l / 2) }) } else { e(t.targets).css({ "padding-left": Math.floor(l / 2), "padding-right": Math.floor(l / 2) }) } } }) }, destroy: function (t) { return this.each(function () { if (t.vertical) { e(t.targets).each(function () { e(this).css({ "padding-top": "", "padding-bottom": "", width: "" }) }) } else { e(t.targets).each(function () { e(this).css({ "padding-left": "", "padding-right": "", width: "" }) }) } e(parent).removeClass("dynPadding_parent").removeData("dynPadding") }) } }; e.fn.dynPadding = function () { var n = arguments[0]; if (t[n]) { n = t[n]; arguments = Array.prototype.slice.call(arguments, 1) } else if (typeof n == "object" || !n) { n = t.init } else { e.error("Method " + n + " does not exist on jQuery.pluginName"); return this } return n.apply(this, arguments) } })(jQuery);
